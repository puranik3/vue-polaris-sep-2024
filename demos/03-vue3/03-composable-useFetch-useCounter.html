<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Hello Vue</title>
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.3/css/bootstrap.min.css"
        />
    </head>
    <body>
        <div id="app"></div>

        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.7.16/vue.min.js"></script> -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.5.4/vue.global.min.js"></script>

        <script src="https://cdn.jsdelivr.net/npm/axios@0.21.1/dist/axios.js"></script>

        <script>
            const { computed, onMounted, reactive, ref, toRefs, watch } = Vue;

            const getWorkshops = async (page = 1) => {
                const response = await axios.get(
                    `https://workshops-server.onrender.com/workshops`,
                    {
                        params: {
                            _page: page,
                        },
                    }
                );

                return response.data;
            };

            // A composable that fetches data from the given source (using the given `fetcher` function that makes the backend call and returns the data)
            const useFetch = (fetcher, initialData) => {
                // --- data ---
                const state = reactive({
                    loading: true,
                    error: null,
                    data: initialData,
                });

                // -- methods --
                const fetchData = async () => {
                    state.loading = true;

                    try {
                        const data = await fetcher();

                        // update data
                        // observe that for data created using reactive(), there is no ".value" used to refer to or update the value
                        state.data = data;
                    } catch (error) {
                        state.error = error;
                    } finally {
                        state.loading = false;
                    }
                };

                // -- lifecycle methods ---
                onMounted(fetchData);

                // --- ready the data to be passed back to the component ---
                // this wont work - when we destructure - the individual pieces ie. loading, error, data are not reactive - UI wont update
                // const { loading, error, data } = state;

                // using toRefs() will make these reactive as well
                const { loading, error, data } = toRefs(state);

                return {
                    loading,
                    error,
                    data,
                    fetchData, // the component may need to fetch data at other times (apart from at the time of mount)
                };
            };

            const WorkshopsList = {
                name: "WorkshopsList",
                setup(props, context) {
                    // --- data ---
                    const page = ref(1);

                    const fetcher = async () => {
                        return await getWorkshops(page.value);
                    };

                    // like we normally use functions, the composables can be passed arguments for customization
                    const {
                        loading,
                        error,
                        data: workshops,
                        fetchData,
                    } = useFetch(fetcher, []);

                    // --- methods ---
                    // Methods are defined directly within setup function
                    const previous = () => {
                        --page.value;
                    };

                    const next = () => {
                        ++page.value;
                    };

                    // --- lifecycle methods ---

                    // created (if you want to use)
                    // await getWorkshops() // this will work in SFC as well

                    // mounted (what we choose to use instead of created)
                    // onMounted(fetchWorkshops); // we moved this to useFetch() composable

                    // -- watchers ---
                    // watching data changes using composition API
                    // newValues -> [ newPage, newX, newY ]
                    // oldValue -> [ oldPage, oldX, oldY ]
                    // Note: May be oldX === newX -> true (but at least one of page, x, y would have changed)
                    // watch( [ page, x, y ], (newValues, oldValue) => {
                    // ...
                    // });

                    // we want to watch only 1 value -> page
                    // Note that we provide the reactive variable and not with ".value"
                    watch(page, fetchData);

                    const pageInfo = computed(() => {
                        return `You are viewing page ${page.value}`;
                    });

                    // expose these to the template using state created using reactive()... - works
                    // return {
                    //     state,
                    // };

                    return {
                        loading, // destructured from reactive
                        error, // ...
                        workshops, // ...
                        page, // ref
                        previous,
                        next,
                        pageInfo,
                    };
                },
                // watch: {
                //     page() {
                //         this.fetchWorkshops();
                //     }
                // },
                template: `
                    <div>
                        <div>{{ pageInfo }}</div>
                        <div v-if="loading">
                            Loading workshops...
                        </div>
                        <div v-else-if="error">
                            {{ error.message }}
                        </div>
                        <div v-else>
                            <button class="btn btn-sm btn-primary" @click="previous">Previous</button>
                            <button class="btn btn-sm btn-primary" @click="next">Next</button>
                            <ul>
                                <li v-for="workshop of workshops" :key="workshop.id">
                                    {{ workshop.name }}
                                </li>
                            </ul>
                        </div>
                    </div>
                `,
            };

            const root = Vue.createApp({
                components: {
                    WorkshopsList,
                },
                data() {
                    return {};
                },
                template: `
                    <div class="container my-5">
                        <workshops-list></workshops-list>
                    </div>
                `,
            });

            root.mount("#app");
        </script>
    </body>
</html>
